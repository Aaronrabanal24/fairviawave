name: Uptime Check

on:
  schedule:
    # Run every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  health-check:
    runs-on: ubuntu-latest
    env:
      PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Unit tests
        run: npm test

      - name: Check Production Health
        run: |
          if [ -z "$PRODUCTION_URL" ]; then
            echo "Skipping health check (PRODUCTION_URL not set)."
            exit 0
          fi

          response=$(curl -sSL -w "%{http_code}" -o /tmp/response.json "$PRODUCTION_URL/api/health")

          if [ "$response" != "200" ]; then
            echo "‚ùå Health check failed with status: $response"
            cat /tmp/response.json
            exit 1
          fi

          if ! jq -e '.ok == true' /tmp/response.json > /dev/null; then
            echo "‚ùå Health check returned ok: false"
            cat /tmp/response.json
            exit 1
          fi

          echo "‚úÖ Health check passed"
          jq '.' /tmp/response.json

      - name: Check Metrics Summary Thresholds
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
        run: |
          python - <<'PY'
          import json
          import os
          import sys
          import time
          import urllib.error
          import urllib.request

          base = os.environ.get("PRODUCTION_URL", "").rstrip('/')
          if not base:
              print("Missing PRODUCTION_URL; skipping metrics check.")
              sys.exit(0)
          url = f"{base}/api/metrics/summary"


          def timed_fetch() -> tuple[int, bytes, float]:
              start = time.perf_counter()
              try:
                  with urllib.request.urlopen(url, timeout=10) as resp:
                      body = resp.read()
                      status = resp.getcode()
              except urllib.error.URLError as exc:  # network issues / timeouts
                  sys.exit(f"Failed to reach metrics endpoint: {exc}")
              elapsed_ms = (time.perf_counter() - start) * 1000
              return status, body, elapsed_ms


          status, body, first_latency = timed_fetch()
          print(f"Metrics status: {status}")

          if status != 200:
              print(body.decode("utf-8", errors="ignore"))
              sys.exit(f"Metrics endpoint returned {status}")

          try:
              data = json.loads(body.decode("utf-8"))
          except json.JSONDecodeError as exc:
              sys.exit(f"Failed to parse metrics JSON: {exc}")

          total_units = data.get("total_units") or 0
          published_units = data.get("published_units") or 0
          events_last_24h = data.get("events_last_24h") or 0

          if total_units > 0:
              published_rate = published_units / total_units
              print(f"Published rate: {published_rate:.2%}")
              if published_rate < 0.30:
                  sys.exit(f"Published rate below threshold: {published_rate:.2%}")
          else:
              print("No units present; skipping publish rate threshold check.")

          if published_units > 0 and events_last_24h == 0:
              sys.exit("Published units exist but no events recorded in the last 24h.")

          latency_samples = [first_latency]

          for _ in range(9):
              status, _, elapsed = timed_fetch()
              if status != 200:
                  sys.exit(f"Metrics endpoint returned {status} during latency sampling")
              latency_samples.append(elapsed)

          latency_samples.sort()
          p95_index = max(int(round(len(latency_samples) * 0.95)) - 1, 0)
          p95_latency = latency_samples[p95_index]

          print("Latency samples (ms):", ", ".join(f"{sample:.1f}" for sample in latency_samples))
          print(f"P95 latency: {p95_latency:.2f} ms")

          if p95_latency > 500:
              sys.exit(f"P95 latency {p95_latency:.2f} ms exceeds 500 ms threshold")

          print("‚úÖ Metrics thresholds passed")
          PY

      - name: Public timeline smoke
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
          PUBLIC_UNIT_ID: ${{ secrets.PUBLIC_UNIT_ID }}
        run: |
          set -euo pipefail
          echo "Hitting $PRODUCTION_URL"
          test -n "$PRODUCTION_URL" || { echo "Missing PRODUCTION_URL"; exit 1; }

          curl -fsS "$PRODUCTION_URL/api/health" >/dev/null

          if [ -n "$PUBLIC_UNIT_ID" ]; then
            curl -fsS "$PRODUCTION_URL/api/units/$PUBLIC_UNIT_ID/timeline/public" >/dev/null || {
              echo "Public timeline smoke failed"; exit 1; }
            echo "‚úÖ Public timeline smoke passed"
          else
            echo "Skipping public timeline smoke; PUBLIC_UNIT_ID not configured."
          fi

      - name: Notify on Failure
        if: failure()
        run: |
          echo "üö® Production health check failed!"
          echo "Check the logs above for details"
          # Add notification logic here (Slack, Discord, email, etc.)

  gate:
    runs-on: ubuntu-latest
    outputs:
      ok: ${{ steps.eval.outputs.ok }}
    steps:
      - id: eval
        env:
          P: ${{ secrets.PRODUCTION_URL }}
          I: ${{ secrets.PUBLIC_UNIT_ID }}
        run: |
          if [ -n "$P" ] && [ -n "$I" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
          else
            echo "ok=false" >> "$GITHUB_OUTPUT"
            echo "Skipping quality checks; required secrets missing."
          fi

  quality-checks:
    needs: [health-check, gate]
    if: ${{ needs.gate.outputs.ok == 'true' }}
    runs-on: ubuntu-latest
    env:
      E2E_BASE_URL: ${{ secrets.PRODUCTION_URL }}
      PUBLIC_UNIT_ID: ${{ secrets.PUBLIC_UNIT_ID }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - run: npm ci

      - run: npx playwright install --with-deps

      - name: Guard for legacy tests
        run: npm run check:old-tests

      - name: Run E2E suite
        run: npm run test:e2e

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report
          if-no-files-found: ignore
